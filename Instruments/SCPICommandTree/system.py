class System:
    """
    TODO: Add the description
    """
    def __init__(self):
        """
    
        """
        self.instrument = None

    
    def set_system_alternate(self, value: int):
        """
        Selects an alternate instrument state, which is swapped with the current state at the end of some specified action.
        The <numeric_value> selects which of the states will be used. The states are created with the *SAV command.
        :param value: The numeric value selecting the alternate state.
        """
        self.instrument.write(f":SYST:ALT {value}")

    def get_system_alternate(self) -> int:
        """
        Returns the currently selected alternate instrument state.
        """
        response = self.instrument.query(":SYST:ALT?").strip()
        try:
            return int(response)
        except ValueError:
            raise ValueError(f"Unexpected response for system alternate state (not integer): '{response}'")

    def set_system_alternate_state(self, enable: bool):
        """
        Controls whether the alternate state mode is enabled. While it is ON, the device shall swap
        the active state with the one stored in the register specified in ALTernate.
        :param enable: True to enable alternate state mode, False to disable.
        """
        scpi_value = "1" if enable else "0"
        self.instrument.write(f":SYST:ALT:STATE {scpi_value}")

    def get_system_alternate_state(self) -> bool:
        """
        Returns True if the alternate state mode is enabled, False if disabled.
        """
        response = self.instrument.query(":SYST:ALT:STATE?").strip()
        if response == "1" or response.upper() == "ON":
            return True
        elif response == "0" or response.upper() == "OFF":
            return False
        else:
            raise ValueError(f"Unexpected response for system alternate state: '{response}'")
    def set_system_beeper_enable(self, value):
        """
        Enables or disables system beeper
        :param value: 1|ON or 0|OFF
        """
        self.instrument.write(f":SYST:BEEP {value}")
    def get_system_beeper_enable(self):
        """
        Enables or disables system beeper
        :param value: 1|ON or 0|OFF
        """
        return self.instrument.query(f":SYST:BEEP?")
    def set_system_beeper_frequency(self, value: float):
        """
        Programs the frequency of audible tones in Hz. It also sets the default frequency for the [:IMMediate] command.
        :param value: The frequency in Hz (numeric value).
        """
        self.instrument.write(f":SYST:BEEP:FREQ {value}")

    def get_system_beeper_frequency(self) -> float:
        """
        Returns the frequency of audible tones in Hz.
        """
        response = self.instrument.query(":SYST:BEEP:FREQ?").strip()
        try:
            return float(response)
        except ValueError:
            raise ValueError(f"Unexpected response for system beeper frequency (not numeric): '{response}'")

    
    def system_beeper_immediate(self, frequency: float = None, time: float = None, volume: float = None):
        """
        Causes an audible tone to be generated by the instrument.
        :param frequency: Optional. The frequency in Hz (numeric value). If None, uses default.
        :param time: Optional. The duration time in seconds (numeric value). If None, uses default.
        :param volume: Optional. The volume (numeric value from 0 to 1). If None, uses default.
        Notes: This command generates an event and therefore it has no associated *RST state or query form.
        """
        params = []
        if frequency is not None:
            params.append(str(frequency))
        if time is not None:
            params.append(str(time))
        if volume is not None:
            params.append(str(volume))

        param_str = ",".join(params)
        self.instrument.write(f":SYST:BEEP:IMM {param_str}")

    def set_system_beeper_state(self, enable: bool):
        """
        Enables/disables the beeper. When STATE OFF is selected, no instrument condition, except
        the :SYSTem:BEEPer:IMMediate command, shall cause an audible beep to be emitted.
        :param enable: True to enable beeper, False to disable.
        """
        scpi_value = "1" if enable else "0"
        self.instrument.write(f":SYST:BEEP:STATE {scpi_value}")

    def get_system_beeper_state(self) -> bool:
        """
        Returns True if the beeper is enabled, False if disabled.
        """
        response = self.instrument.query(":SYST:BEEP:STATE?").strip()
        if response == "1" or response.upper() == "ON":
            return True
        elif response == "0" or response.upper() == "OFF":
            return False
        else:
            raise ValueError(f"Unexpected response for system beeper state: '{response}'")

    def set_system_beeper_time(self, value: float):
        """
        Programs the duration of audible tones in seconds. It also sets the default duration for the [:IMMediate] command.
        :param value: The duration in seconds (numeric value).
        """
        self.instrument.write(f":SYST:BEEP:TIME {value}")

    def get_system_beeper_time(self) -> float:
        """
        Returns the duration of audible tones in seconds.
        """
        response = self.instrument.query(":SYST:BEEP:TIME?").strip()
        try:
            return float(response)
        except ValueError:
            raise ValueError(f"Unexpected response for system beeper time (not numeric): '{response}'")

    def set_system_beeper_volume(self, value: float):
        """
        Programs the volume of audible tones. It also sets the default volume for the [:IMMediate] command.
        :param value: The volume (numeric value from 0 to 1).
        """
        if not (0 <= value <= 1):
            raise ValueError("Volume must be between 0 and 1.")
        self.instrument.write(f":SYST:BEEP:VOL {value}")

    def get_system_beeper_volume(self) -> float:
        """
        Returns the volume of audible tones.
        """
        response = self.instrument.query(":SYST:BEEP:VOL?").strip()
        try:
            return float(response)
        except ValueError:
            raise ValueError(f"Unexpected response for system beeper volume (not numeric): '{response}'")

    def get_system_capability(self) -> str:
        """
        Returns an <instrument_specifier> indicating the instrument's capabilities.
        Notes: Query only.
        """
        response = self.instrument.query(":SYST:CAP?").strip()
        return response

    
    def set_system_communicate_centronics_feed(self, data_handle: str):
        """
        Sets what data is used to FEED the remote CENTronics device.
        :param data_handle: The data handle (character data).
        """
        self.instrument.write(f":SYST:COMM:CENT:FEED '{data_handle}'")

    def get_system_communicate_centronics_feed(self) -> str:
        """
        Returns what data is used to FEED the remote CENTronics device.
        """
        response = self.instrument.query(":SYST:COMM:CENT:FEED?").strip().strip("'")
        return response

    def set_system_communicate_gpib_rdevice_address(self, primary_address: int, secondary_address: int = None):
        """
        Sets the bus address of the peripheral device connected to a GPIB port.
        :param primary_address: The primary address (numeric value).
        :param secondary_address: Optional. The secondary address (numeric value).
        """
        if secondary_address is not None:
            self.instrument.write(f":SYST:COMM:GPIB:RDEV:ADDR {primary_address},{secondary_address}")
        else:
            self.instrument.write(f":SYST:COMM:GPIB:RDEV:ADDR {primary_address}")

    def get_system_communicate_gpib_rdevice_address(self) -> tuple[int, int]:
        """
        Returns the bus address of the peripheral device connected to a GPIB port.
        :return: A tuple containing (primary_address, secondary_address or None).
        """
        response = self.instrument.query(":SYST:COMM:GPIB:RDEV:ADDR?").strip()
        try:
            parts = [int(p) for p in response.split(',')]
            if len(parts) == 1:
                return (parts[0], None)
            elif len(parts) == 2:
                return (parts[0], parts[1])
            else:
                raise ValueError("Unexpected address format.")
        except ValueError:
            raise ValueError(f"Unexpected response for GPIB RDEVice address (not numeric or invalid format): '{response}'")

    def set_system_communicate_gpib_rdevice_feed(self, data_handle: str):
        """
        Sets what data is used to FEED the peripheral device connected to a GPIB port.
        :param data_handle: The data handle (character data).
        """
        self.instrument.write(f":SYST:COMM:GPIB:RDEV:FEED '{data_handle}'")

    def get_system_communicate_gpib_rdevice_feed(self) -> str:
        """
        Returns what data is used to FEED the peripheral device connected to a GPIB port.
        """
        response = self.instrument.query(":SYST:COMM:GPIB:RDEV:FEED?").strip().strip("'")
        return response

    def set_system_communicate_gpib_self_address(self, primary_address: int, secondary_address: int = None):
        """
        Sets the GPIB address of the instrument itself.
        :param primary_address: The primary address (numeric value).
        :param secondary_address: Optional. The secondary address (numeric value).
        """
        if secondary_address is not None:
            self.instrument.write(f":SYST:COMM:GPIB:SELF:ADDR {primary_address},{secondary_address}")
        else:
            self.instrument.write(f":SYST:COMM:GPIB:SELF:ADDR {primary_address}")

    def get_system_communicate_gpib_self_address(self) -> tuple[int, int]:
        """
        Returns the GPIB address of the instrument itself.
        :return: A tuple containing (primary_address, secondary_address or None).
        """
        response = self.instrument.query(":SYST:COMM:GPIB:SELF:ADDR?").strip()
        try:
            parts = [int(p) for p in response.split(',')]
            if len(parts) == 1:
                return (parts[0], None)
            elif len(parts) == 2:
                return (parts[0], parts[1])
            else:
                raise ValueError("Unexpected address format.")
        except ValueError:
            raise ValueError(f"Unexpected response for GPIB SELF address (not numeric or invalid format): '{response}'")

    
    def set_system_communicate_serial_control_dtr(self, mode: str):
        """
        Sets the hardware pacing scheme for the DTR (Data Terminal Ready) line on the serial port.
        :param mode: ON|OFF|STANdard|IBFull
        """
        valid_modes = {"ON", "OFF", "STANDARD", "IBFULL", "STAN", "IBF"}
        mode_upper = mode.upper()
        if mode_upper not in valid_modes:
            raise ValueError(f"Invalid DTR mode: '{mode}'. Must be 'ON', 'OFF', 'STANdard', or 'IBFull'.")
        if mode_upper == "STANDARD": scpi_value = "STAN"
        elif mode_upper == "IBFULL": scpi_value = "IBF"
        else: scpi_value = mode_upper
        self.instrument.write(f":SYST:COMM:SER:CONT:DTR {scpi_value}")

    def get_system_communicate_serial_control_dtr(self) -> str:
        """
        Returns the hardware pacing scheme for the DTR line on the serial port.
        """
        response = self.instrument.query(":SYST:COMM:SER:CONT:DTR?").strip().upper()
        if response == "ON": return "ON"
        elif response == "OFF": return "OFF"
        elif response.startswith("STAN"): return "STANDARD"
        elif response.startswith("IBF"): return "IBFULL"
        return response

    def set_system_communicate_serial_control_rts(self, mode: str):
        """
        Sets the hardware pacing (hand-shaking) scheme for the RTS (Request To Send) line on the serial port.
        :param mode: ON|OFF|STANdard|IBFull|RFR
        """
        valid_modes = {"ON", "OFF", "STANDARD", "IBFULL", "RFR", "STAN", "IBF"}
        mode_upper = mode.upper()
        if mode_upper not in valid_modes:
            raise ValueError(f"Invalid RTS mode: '{mode}'. Must be 'ON', 'OFF', 'STANdard', 'IBFull', or 'RFR'.")
        if mode_upper == "STANDARD": scpi_value = "STAN"
        elif mode_upper == "IBFULL": scpi_value = "IBF"
        else: scpi_value = mode_upper
        self.instrument.write(f":SYST:COMM:SER:CONT:RTS {scpi_value}")

    def get_system_communicate_serial_control_rts(self) -> str:
        """
        Returns the hardware pacing (hand-shaking) scheme for the RTS line on the serial port.
        """
        response = self.instrument.query(":SYST:COMM:SER:CONT:RTS?").strip().upper()
        if response == "ON": return "ON"
        elif response == "OFF": return "OFF"
        elif response.startswith("STAN"): return "STANDARD"
        elif response.startswith("IBF"): return "IBFULL"
        elif response.startswith("RFR"): return "RFR"
        return response

    
    def set_system_communicate_serial_feed(self, data_handle: str):
        """
        Sets what data is used to FEED the peripheral device connected to the serial port.
        :param data_handle: The data handle (character data).
        """
        self.instrument.write(f":SYST:COMM:SER:FEED '{data_handle}'")

    def get_system_communicate_serial_feed(self) -> str:
        """
        Returns what data is used to FEED the peripheral device connected to the serial port.
        """
        response = self.instrument.query(":SYST:COMM:SER:FEED?").strip().strip("'")
        return response

    def set_system_communicate_serial_receive_baud(self, value: int):
        """
        Sets the baud rate for the serial receive channel.
        :param value: The baud rate (numeric value).
        """
        self.instrument.write(f":SYST:COMM:SER:REC:BAUD {value}")

    def get_system_communicate_serial_receive_baud(self) -> int:
        """
        Returns the baud rate for the serial receive channel.
        """
        response = self.instrument.query(":SYST:COMM:SER:REC:BAUD?").strip()
        try:
            return int(response)
        except ValueError:
            raise ValueError(f"Unexpected response for serial receive baud rate (not integer): '{response}'")

    def set_system_communicate_serial_receive_bits(self, value: int):
        """
        Sets the number of data bits for the serial receive channel, typically 7 or 8.
        :param value: The number of data bits (numeric value).
        """
        self.instrument.write(f":SYST:COMM:SER:REC:BITS {value}")

    def get_system_communicate_serial_receive_bits(self) -> int:
        """
        Returns the number of data bits for the serial receive channel.
        """
        response = self.instrument.query(":SYST:COMM:SER:REC:BITS?").strip()
        try:
            return int(response)
        except ValueError:
            raise ValueError(f"Unexpected response for serial receive bits (not integer): '{response}'")

    def set_system_communicate_serial_receive_pace(self, mode: str):
        """
        Sets the software pacing scheme for the serial receive channel.
        :param mode: XON|ACK|NONE
        """
        valid_modes = {"XON", "ACK", "NONE"}
        mode_upper = mode.upper()
        if mode_upper not in valid_modes:
            raise ValueError(f"Invalid PACE mode: '{mode}'. Must be 'XON', 'ACK', or 'NONE'.")
        self.instrument.write(f":SYST:COMM:SER:REC:PACE {mode_upper}")

    def get_system_communicate_serial_receive_pace(self) -> str:
        """
        Returns the software pacing scheme for the serial receive channel.
        """
        response = self.instrument.query(":SYST:COMM:SER:REC:PACE?").strip().upper()
        return response

    
    def set_system_communicate_serial_receive_pace_threshold_start(self, value: int):
        """
        Indicates that when the number of characters in the device's input buffer goes to or below the indicated amount and some form of pacing has been set,
        the device should indicate that it is ready to receive.
        :param value: The start threshold (numeric value).
        """
        self.instrument.write(f":SYST:COMM:SER:REC:PACE:THRES:STAR {value}")

    def get_system_communicate_serial_receive_pace_threshold_start(self) -> int:
        """
        Returns the start threshold for receive pacing.
        """
        response = self.instrument.query(":SYST:COMM:SER:REC:PACE:THRES:STAR?").strip()
        try:
            return int(response)
        except ValueError:
            raise ValueError(f"Unexpected response for serial receive pace threshold start (not integer): '{response}'")

    def set_system_communicate_serial_receive_pace_threshold_stop(self, value: int):
        """
        Indicates that when the number of characters in the device's input buffer goes to or above the indicated amount and some form of pacing has been set,
        the device should indicate that it is not ready to receive.
        :param value: The stop threshold (numeric value).
        """
        self.instrument.write(f":SYST:COMM:SER:REC:PACE:THRES:STOP {value}")

    def get_system_communicate_serial_receive_pace_threshold_stop(self) -> int:
        """
        Returns the stop threshold for receive pacing.
        """
        response = self.instrument.query(":SYST:COMM:SER:REC:PACE:THRES:STOP?").strip()
        try:
            return int(response)
        except ValueError:
            raise ValueError(f"Unexpected response for serial receive pace threshold stop (not integer): '{response}'")

    def set_system_communicate_serial_receive_parity_check(self, enable: bool):
        """
        When CHECK ON is selected, the parity shall be checked in accordance with the selected PARity:TYPE.
        :param enable: True to enable parity check, False to disable.
        """
        scpi_value = "1" if enable else "0"
        self.instrument.write(f":SYST:COMM:SER:REC:PAR:CHEC {scpi_value}")

    def get_system_communicate_serial_receive_parity_check(self) -> bool:
        """
        Returns True if parity check is enabled for the serial receive channel, False if disabled.
        """
        response = self.instrument.query(":SYST:COMM:SER:REC:PAR:CHEC?").strip()
        if response == "1" or response.upper() == "ON":
            return True
        elif response == "0" or response.upper() == "OFF":
            return False
        else:
            raise ValueError(f"Unexpected response for serial receive parity check state: '{response}'")

    def set_system_communicate_serial_receive_parity_type(self, parity_type: str):
        """
        Sets the parity scheme that is to be employed for reception.
        :param parity_type: EVEN|ODD|ZERO|ONE|NONE|IGNore
        """
        valid_types = {"EVEN", "ODD", "ZERO", "ONE", "NONE", "IGNORE", "IGN"}
        type_upper = parity_type.upper()
        if type_upper not in valid_types:
            raise ValueError(f"Invalid parity type: '{parity_type}'.")
        if type_upper == "IGNORE": scpi_value = "IGN"
        else: scpi_value = type_upper
        self.instrument.write(f":SYST:COMM:SER:REC:PAR:TYPE {scpi_value}")

    def get_system_communicate_serial_receive_parity_type(self) -> str:
        """
        Returns the parity scheme employed for reception.
        """
        response = self.instrument.query(":SYST:COMM:SER:REC:PAR:TYPE?").strip().upper()
        if response.startswith("IGN"): return "IGNORE"
        return response

    def set_system_communicate_serial_receive_sbits(self, value: float):
        """
        Sets the number of stop bits for the serial receive channel, typically 1, 1.5 or 2 bits.
        :param value: The number of stop bits (numeric value).
        """
        self.instrument.write(f":SYST:COMM:SER:REC:SBITS {value}")

    def get_system_communicate_serial_receive_sbits(self) -> float:
        """
        Returns the number of stop bits for the serial receive channel.
        """
        response = self.instrument.query(":SYST:COMM:SER:REC:SBITS?").strip()
        try:
            return float(response)
        except ValueError:
            raise ValueError(f"Unexpected response for serial receive stop bits (not numeric): '{response}'")

    
    def set_system_communicate_serial_transmit_auto(self, enable: bool):
        """
        Couples the TRANsmit parameter values to the RECeive parameter values when AUTO ON is selected.
        :param enable: True to enable auto-coupling, False to disable.
        """
        scpi_value = "1" if enable else "0"
        self.instrument.write(f":SYST:COMM:SER:TRAN:AUTO {scpi_value}")

    def get_system_communicate_serial_transmit_auto(self) -> bool:
        """
        Returns True if auto-coupling is enabled for serial transmit parameters, False if disabled.
        """
        response = self.instrument.query(":SYST:COMM:SER:TRAN:AUTO?").strip()
        if response == "1" or response.upper() == "ON":
            return True
        elif response == "0" or response.upper() == "OFF":
            return False
        else:
            raise ValueError(f"Unexpected response for serial transmit auto state: '{response}'")

    def set_system_communicate_serial_transmit_baud(self, value: int):
        """
        Sets the baud rate for the serial transmit channel.
        :param value: The baud rate (numeric value).
        """
        self.instrument.write(f":SYST:COMM:SER:TRAN:BAUD {value}")

    def get_system_communicate_serial_transmit_baud(self) -> int:
        """
        Returns the baud rate for the serial transmit channel.
        """
        response = self.instrument.query(":SYST:COMM:SER:TRAN:BAUD?").strip()
        try:
            return int(response)
        except ValueError:
            raise ValueError(f"Unexpected response for serial transmit baud rate (not integer): '{response}'")

    def set_system_communicate_serial_transmit_bits(self, value: int):
        """
        Sets the number of data bits for the serial transmit channel, typically 7 or 8.
        :param value: The number of data bits (numeric value).
        """
        self.instrument.write(f":SYST:COMM:SER:TRAN:BITS {value}")

    def get_system_communicate_serial_transmit_bits(self) -> int:
        """
        Returns the number of data bits for the serial transmit channel.
        """
        response = self.instrument.query(":SYST:COMM:SER:TRAN:BITS?").strip()
        try:
            return int(response)
        except ValueError:
            raise ValueError(f"Unexpected response for serial transmit bits (not integer): '{response}'")

    def set_system_communicate_serial_transmit_delay(self, value: float):
        """
        Sets the minimum delay in seconds that the device must wait after receipt of a Program Message Terminator before issuing a response message.
        :param value: The delay in seconds (numeric value).
        """
        self.instrument.write(f":SYST:COMM:SER:TRAN:DEL {value}")

    def get_system_communicate_serial_transmit_delay(self) -> float:
        """
        Returns the minimum delay for serial transmit.
        """
        response = self.instrument.query(":SYST:COMM:SER:TRAN:DEL?").strip()
        try:
            return float(response)
        except ValueError:
            raise ValueError(f"Unexpected response for serial transmit delay (not numeric): '{response}'")

    def set_system_communicate_serial_transmit_pace(self, mode: str):
        """
        Sets the software pacing scheme for the serial transmit channel.
        :param mode: XON|ACK|NONE
        """
        valid_modes = {"XON", "ACK", "NONE"}
        mode_upper = mode.upper()
        if mode_upper not in valid_modes:
            raise ValueError(f"Invalid PACE mode: '{mode}'. Must be 'XON', 'ACK', or 'NONE'.")
        self.instrument.write(f":SYST:COMM:SER:TRAN:PACE {mode_upper}")

    def get_system_communicate_serial_transmit_pace(self) -> str:
        """
        Returns the software pacing scheme for the serial transmit channel.
        """
        response = self.instrument.query(":SYST:COMM:SER:TRAN:PACE?").strip().upper()
        return response

    def set_system_communicate_serial_transmit_parity_type(self, parity_type: str):
        """
        Sets the parity scheme that is to be employed for transmission.
        :param parity_type: EVEN|ODD|ZERO|ONE|NONE
        """
        valid_types = {"EVEN", "ODD", "ZERO", "ONE", "NONE"}
        type_upper = parity_type.upper()
        if type_upper not in valid_types:
            raise ValueError(f"Invalid parity type: '{parity_type}'.")
        self.instrument.write(f":SYST:COMM:SER:TRAN:PAR:TYPE {type_upper}")

    def get_system_communicate_serial_transmit_parity_type(self) -> str:
        """
        Returns the parity scheme employed for transmission.
        """
        response = self.instrument.query(":SYST:COMM:SER:TRAN:PAR:TYPE?").strip().upper()
        return response

    def set_system_communicate_serial_transmit_sbits(self, value: float):
        """
        Sets the number of stop bits for the serial transmit channel, typically 1, 1.5, or 2 bits.
        :param value: The number of stop bits (numeric value).
        """
        self.instrument.write(f":SYST:COMM:SER:TRAN:SBITS {value}")

    def get_system_communicate_serial_transmit_sbits(self) -> float:
        """
        Returns the number of stop bits for the serial transmit channel.
        """
        response = self.instrument.query(":SYST:COMM:SER:TRAN:SBITS?").strip()
        try:
            return float(response)
        except ValueError:
            raise ValueError(f"Unexpected response for serial transmit stop bits (not numeric): '{response}'")

    
    def set_system_communicate_socket_address(self, socket_n: int, address: str):
        """
        Allows the user to enter the IP address or host name of the remote device for a specified socket.
        :param socket_n: The socket number.
        :param address: The IP address (e.g., "123.45.67.89") or host name (e.g., "my_host").
        """
        self.instrument.write(f":SYST:COMM:SOCK{socket_n}:ADDR '{address}'")

    def get_system_communicate_socket_address(self, socket_n: int) -> str:
        """
        Returns the IP address or host name of the remote device for a specified socket.
        """
        response = self.instrument.query(f":SYST:COMM:SOCK{socket_n}:ADDR?").strip().strip("'")
        return response

    def system_communicate_socket_connect(self, socket_n: int):
        """
        Implements the socket connection for a specified socket.
        :param socket_n: The socket number.
        """
        self.instrument.write(f":SYST:COMM:SOCK{socket_n}:CONN")

    def system_communicate_socket_disconnect(self, socket_n: int):
        """
        Breaks the socket connection for a specified socket.
        :param socket_n: The socket number.
        """
        self.instrument.write(f":SYST:COMM:SOCK{socket_n}:DISC")

    def set_system_communicate_socket_feed(self, socket_n: int, data_handles: list[str]):
        """
        Sets what data is used to FEED the communications socket.
        :param socket_n: The socket number.
        :param data_handles: A list of data handles (character data).
        """
        formatted_handles = [f"'{dh}'" for dh in data_handles]
        self.instrument.write(f":SYST:COMM:SOCK{socket_n}:FEED {','.join(formatted_handles)}")

    def get_system_communicate_socket_feed(self, socket_n: int) -> list[str]:
        """
        Returns what data is used to FEED the communications socket.
        """
        response = self.instrument.query(f":SYST:COMM:SOCK{socket_n}:FEED?").strip()
        # The response might be comma-separated, possibly with quotes.
        # Example: "'handle1','handle2'" or "handle1,handle2"
        if not response:
            return []
        # Clean up quotes and split by comma
        cleaned_response = response.replace("'", "")
        return [h.strip() for h in cleaned_response.split(',')]

    def set_system_communicate_socket_feed_ocondition(self, socket_n: int, event_handle: str):
        """
        Defines the rate at which data will be collected and sent to the socket FEED.
        :param socket_n: The socket number.
        :param event_handle: The event handle (character data).
        """
        self.instrument.write(f":SYST:COMM:SOCK{socket_n}:FEED:OCON '{event_handle}'")

    def get_system_communicate_socket_feed_ocondition(self, socket_n: int) -> str:
        """
        Returns the event handle defining the rate at which data will be collected and sent to the socket FEED.
        """
        response = self.instrument.query(f":SYST:COMM:SOCK{socket_n}:FEED:OCON?").strip().strip("'")
        return response

    def set_system_communicate_socket_feed_scondition(self, socket_n: int, event_handle: str):
        """
        Defines the rate at which the data will be transmitted on the socket.
        :param socket_n: The socket number.
        :param event_handle: The event handle (character data).
        """
        self.instrument.write(f":SYST:COMM:SOCK{socket_n}:FEED:SCON '{event_handle}'")

    def get_system_communicate_socket_feed_scondition(self, socket_n: int) -> str:
        """
        Returns the event handle defining the rate at which the data will be transmitted on the socket.
        """
        response = self.instrument.query(f":SYST:COMM:SOCK{socket_n}:FEED:SCON?").strip().strip("'")
        return response

    def system_communicate_socket_listen(self, socket_n: int):
        """
        Instructs the device (instrument) to listen for a connection on the specified socket.
        :param socket_n: The socket number.
        """
        self.instrument.write(f":SYST:COMM:SOCK{socket_n}:LIST")

    def set_system_communicate_socket_port(self, socket_n: int, port_number: int):
        """
        Allows the user to enter the port number for a specified socket.
        :param socket_n: The socket number.
        :param port_number: The port number (16-bit integer).
        """
        self.instrument.write(f":SYST:COMM:SOCK{socket_n}:PORT {port_number}")

    def get_system_communicate_socket_port(self, socket_n: int) -> int:
        """
        Returns the port number for a specified socket.
        """
        response = self.instrument.query(f":SYST:COMM:SOCK{socket_n}:PORT?").strip()
        try:
            return int(response)
        except ValueError:
            raise ValueError(f"Unexpected response for socket port (not integer): '{response}'")

    
    def set_system_communicate_socket_type(self, socket_n: int, socket_type: str):
        """
        Allows the user to select the type of Ethernet port to be opened.
        :param socket_n: The socket number.
        :param socket_type: TCP|UDP
        """
        valid_types = {"TCP", "UDP"}
        type_upper = socket_type.upper()
        if type_upper not in valid_types:
            raise ValueError(f"Invalid socket type: '{socket_type}'. Must be 'TCP' or 'UDP'.")
        self.instrument.write(f":SYST:COMM:SOCK{socket_n}:TYPE {type_upper}")

    def get_system_communicate_socket_type(self, socket_n: int) -> str:
        """
        Returns the type of Ethernet port for a specified socket.
        """
        response = self.instrument.query(f":SYST:COMM:SOCK{socket_n}:TYPE?").strip().upper()
        return response

    def system_cpon(self, card_destination: str):
        """
        Card Power ON resets a card within a cardcage to its power-on state.
        :param card_destination: The module number, user-defined card name, or "ALL".
        Notes: This is an event; no query is allowed.
        """
        if card_destination.upper() == "ALL":
            self.instrument.write(":SYST:CPON ALL")
        else:
            # Assuming card_destination can be a string name or a numeric module number
            try:
                # Try to convert to int if it's a number
                int_val = int(card_destination)
                self.instrument.write(f":SYST:CPON {int_val}")
            except ValueError:
                # Otherwise treat as string name
                self.instrument.write(f":SYST:CPON '{card_destination}'")


    def get_system_ctype(self, card_destination: str) -> str:
        """
        The Card TYPe query identifies a card within a cardcage.
        :param card_destination: The module number or user-defined card name.
        :return: The identification string, identical to *IDN? format.
        """
        try:
            # Try to convert to int if it's a number
            int_val = int(card_destination)
            response = self.instrument.query(f":SYST:CTYP? {int_val}").strip()
        except ValueError:
            # Otherwise treat as string name
            response = self.instrument.query(f":SYST:CTYP? '{card_destination}'").strip()
        return response

    def set_system_date(self, year: int, month: int, day: int):
        """
        Sets the internal calendar of the instrument.
        :param year: The year (four-digit numeric value).
        :param month: The month (numeric value, 1-12).
        :param day: The day (numeric value, 1-31, validated against month/year).
        Notes: This shall not be affected by a *RST command.
        """
        if not (1 <= month <= 12):
            raise ValueError("Month must be between 1 and 12.")
        if not (1 <= day <= 31): # Basic check, more detailed validation can be added
            raise ValueError("Day must be between 1 and 31.")
        self.instrument.write(f":SYST:DATE {year},{month},{day}")

    def get_system_date(self) -> tuple[int, int, int]:
        """
        Returns the internal calendar date of the instrument.
        :return: A tuple (year, month, day).
        """
        response = self.instrument.query(":SYST:DATE?").strip()
        try:
            parts = [int(p) for p in response.split(',')]
            if len(parts) == 3:
                return tuple(parts)
            else:
                raise ValueError("Unexpected date format.")
        except ValueError:
            raise ValueError(f"Unexpected response for system date (not numeric or invalid format): '{response}'")

        # These functions are designed to be generic and can be called with various error types.

    def get_system_error_all(self) -> str:
        """
        Queries all errors from the error queue, returning a string that includes all error codes and messages.
        Notes: Query only.
        """
        response = self.instrument.query(":SYST:ERR:ALL?").strip()
        return response

    def get_system_error_code_all(self) -> str:
        """
        Queries all error codes from the error queue.
        Notes: Query only.
        """
        response = self.instrument.query(":SYST:ERR:CODE:ALL?").strip()
        return response

    def get_system_error(self) -> str:
        """
        Queries the next error from the error queue, returning its code and message.
        Notes: Query only.
        """
        response = self.instrument.query(":SYST:ERR:NEXT?").strip()
        return response

    def get_system_error_count(self) -> int:
        """
        Queries the number of errors currently in the error queue.
        Notes: Query only.
        """
        response = self.instrument.query(":SYST:ERR:COUN?").strip()
        try:
            return int(response)
        except ValueError:
            raise ValueError(f"Unexpected response for system error count (not integer): '{response}'")

    def add_system_error_enable(self, error_numbers: list[int]):
        """
        Adds error numbers to the enable list, so they are reported.
        :param error_numbers: A list of numeric error numbers.
        Notes: No query form.
        """
        self.instrument.write(f":SYST:ERR:ENAB:ADD {','.join(map(str, error_numbers))}")

    def delete_system_error_enable(self, error_numbers: list[int]):
        """
        Deletes error numbers from the enable list.
        :param error_numbers: A list of numeric error numbers.
        Notes: No query form.
        """
        self.instrument.write(f":SYST:ERR:ENAB:DEL {','.join(map(str, error_numbers))}")

    def delete_system_error_enable_list(self):
        """
        Deletes all error numbers from the enable list.
        Notes: No query form.
        """
        self.instrument.write(":SYST:ERR:ENAB:DEL:LIST")

    
    def get_system_help_headers(self, command_header: str = None) -> str:
        """
        Returns a list of command headers for the instrument. If a command_header is specified,
        returns help for that specific command.
        :param command_header: Optional. The command header string (e.g., "SYSTem:BEEPer").
        Notes: Query only.
        """
        if command_header:
            return self.instrument.query(f":SYST:HELP:HEAD? '{command_header}'").strip()
        else:
            return self.instrument.query(":SYST:HELP:HEAD?").strip()

    def get_system_help_syntax(self, command_header: str = None) -> str:
        """
        Returns the syntax for a command. If a command_header is specified, returns syntax for
        that specific command.
        :param command_header: Optional. The command header string.
        Notes: Query only.
        """
        if command_header:
            return self.instrument.query(f":SYST:HELP:SYNT? '{command_header}'").strip()
        else:
            return self.instrument.query(":SYST:HELP:SYNT?").strip()

    
    def set_system_key_define(self, key_number: int, block_data: str, string_label: str = None):
        """
        Defines a softkey function.
        :param key_number: The numeric value of the key to define.
        :param block_data: The block data defining the key's function.
        :param string_label: Optional. A string label for the key.
        Notes: No query form.
        """
        if string_label:
            self.instrument.write(f":SYST:KEY:DEF {key_number},{block_data},'{string_label}'")
        else:
            self.instrument.write(f":SYST:KEY:DEF {key_number},{block_data}")

    def system_key_delete(self, key_number: int):
        """
        Deletes a user-defined softkey.
        :param key_number: The numeric value of the key to delete.
        Notes: No query form.
        """
        self.instrument.write(f":SYST:KEY:DEL {key_number}")

    
    def set_system_klock(self, enable: bool):
        """
        Locks or unlocks the front panel keyboard.
        :param enable: True to lock the keyboard, False to unlock.
        """
        scpi_value = "1" if enable else "0"
        self.instrument.write(f":SYST:KLOCK {scpi_value}")

    def get_system_klock(self) -> bool:
        """
        Returns True if the front panel keyboard is locked, False if unlocked.
        """
        response = self.instrument.query(":SYST:KLOCK?").strip()
        if response == "1" or response.upper() == "ON":
            return True
        elif response == "0" or response.upper() == "OFF":
            return False
        else:
            raise ValueError(f"Unexpected response for system KLOCK state: '{response}'")

    
    def set_system_language(self, language: str):
        """
        Sets the display language of the instrument.
        :param language: The language string (e.g., "ENGlish").
        """
        self.instrument.write(f":SYST:LANG '{language}'")

    def get_system_language(self) -> str:
        """
        Returns the display language of the instrument.
        """
        response = self.instrument.query(":SYST:LANG?").strip().strip("'")
        return response

    
    def set_system_lfrequency(self, value: float):
        """
        Sets the line frequency of the instrument's power supply.
        :param value: The line frequency (numeric value).
        """
        self.instrument.write(f":SYST:LFR {value}")

    def get_system_lfrequency(self) -> float:
        """
        Returns the line frequency of the instrument's power supply.
        """
        response = self.instrument.query(":SYST:LFR?").strip()
        try:
            return float(response)
        except ValueError:
            raise ValueError(f"Unexpected response for system LFRequency (not numeric): '{response}'")

    def set_system_lfrequency_auto(self, auto_state: str):
        """
        When enabled, the line frequency is automatically detected.
        :param auto_state: Boolean (ON|OFF) or 'ONCE'. Selecting 'ONCE' sets AUTO to ON and then OFF.
        """
        normalized_state = auto_state.upper()
        if normalized_state in {"1", "ON"}:
            scpi_value = "ON"
        elif normalized_state in {"0", "OFF"}:
            scpi_value = "OFF"
        elif normalized_state == "ONCE":
            scpi_value = "ONCE"
        else:
            raise ValueError(f"Invalid auto state: '{auto_state}'. Must be 'ON', 'OFF', or 'ONCE'.")
        self.instrument.write(f":SYST:LFR:AUTO {scpi_value}")

    def get_system_lfrequency_auto(self) -> str:
        """
        Returns the auto state of the line frequency.
        """
        response = self.instrument.query(":SYST:LFR:AUTO?").strip()
        if response == "1":
            return "ON"
        elif response == "0":
            return "OFF"
        else:
            return response.upper()

    
    def get_system_lock_owner(self) -> int:
        """
        Returns the ID of the resource that currently owns the lock.
        Notes: Query only.
        """
        response = self.instrument.query(":SYST:LOCK:OWN?").strip()
        try:
            return int(response)
        except ValueError:
            raise ValueError(f"Unexpected response for system LOCK owner (not integer): '{response}'")

    def system_lock_release(self):
        """
        Releases the system lock.
        Notes: No query form.
        """
        self.instrument.write(":SYST:LOCK:REL")

    def get_system_lock_request(self) -> bool:
        """
        Returns True if a lock request is pending, False otherwise.
        Notes: Query only.
        """
        response = self.instrument.query(":SYST:LOCK:REQ?").strip()
        if response == "1":
            return True
        elif response == "0":
            return False
        else:
            raise ValueError(f"Unexpected response for system LOCK request (not boolean): '{response}'")

    
    def system_password_cdisable(self, password: str):
        """
        Disables security functions with a password.
        :param password: The password string.
        Notes: Event; no query.
        """
        self.instrument.write(f":SYST:PASS:CDIS '{password}'")

    def system_password_cenable(self, password: str):
        """
        Enables security functions with a password.
        :param password: The password string.
        Notes: Event; no query.
        """
        self.instrument.write(f":SYST:PASS:CEN '{password}'")

    def get_system_password_state(self) -> bool:
        """
        Returns the state of the security password.
        Notes: Query only.
        """
        response = self.instrument.query(":SYST:PASS:STATE?").strip()
        if response == "1" or response.upper() == "ON":
            return True
        elif response == "0" or response.upper() == "OFF":
            return False
        else:
            raise ValueError(f"Unexpected response for system password state: '{response}'")

    def set_system_password_new(self, current_password: str, new_password: str):
        """
        Sets a new password for security functions.
        :param current_password: The current password string.
        :param new_password: The new password string.
        Notes: Event; no query.
        """
        self.instrument.write(f":SYST:PASS:NEW '{current_password}','{new_password}'")

    def system_password_preset(self):
        """
        Resets the password to its default value.
        Notes: Event; no query.
        """
        self.instrument.write(":SYST:PASS:PRES")

    
    def set_system_security_immediate(self, enable: bool):
        """
        Enables or disables security functions immediately.
        :param enable: True to enable, False to disable.
        Notes: Event; no query.
        """
        scpi_value = "1" if enable else "0"
        self.instrument.write(f":SYST:SEC:IMM {scpi_value}")

    def set_system_security_state(self, enable: bool):
        """
        Enables or disables security functions.
        :param enable: True to enable, False to disable.
        """
        scpi_value = "1" if enable else "0"
        self.instrument.write(f":SYST:SEC:STATE {scpi_value}")

    def get_system_security_state(self) -> bool:
        """
        Returns True if security functions are enabled, False if disabled.
        """
        response = self.instrument.query(":SYST:SEC:STATE?").strip()
        if response == "1" or response.upper() == "ON":
            return True
        elif response == "0" or response.upper() == "OFF":
            return False
        else:
            raise ValueError(f"Unexpected response for system security state: '{response}'")

    def set_system_security_set(self, block_data: str):
        """
        Sets security configuration data.
        :param block_data: The block data string.
        Notes: No query form.
        """
        self.instrument.write(f":SYST:SEC:SET {block_data}")

    def set_system_time(self, hour: int, minute: int, second: int):
        """
        Sets the internal time of the instrument.
        :param hour: The hour (numeric value, 0-23).
        :param minute: The minute (numeric value, 0-59).
        :param second: The second (numeric value, 0-59).
        Notes: This shall not be affected by a *RST command.
        """
        if not (0 <= hour <= 23):
            raise ValueError("Hour must be between 0 and 23.")
        if not (0 <= minute <= 59):
            raise ValueError("Minute must be between 0 and 59.")
        if not (0 <= second <= 59):
            raise ValueError("Second must be between 0 and 59.")
        self.instrument.write(f":SYST:TIME {hour},{minute},{second}")

    def get_system_time(self) -> tuple[int, int, int]:
        """
        Returns the internal time of the instrument.
        :return: A tuple (hour, minute, second).
        """
        response = self.instrument.query(":SYST:TIME?").strip()
        try:
            parts = [int(p) for p in response.split(',')]
            if len(parts) == 3:
                return tuple(parts)
            else:
                raise ValueError("Unexpected time format.")
        except ValueError:
            raise ValueError(f"Unexpected response for system time (not numeric or invalid format): '{response}'")

    
    def set_system_timer_count(self, value: int):
        """
        Sets the count for the system timer.
        :param value: The count (numeric value).
        """
        self.instrument.write(f":SYST:TIM:COUN {value}")

    def get_system_timer_count(self) -> int:
        """
        Returns the count for the system timer.
        """
        response = self.instrument.query(":SYST:TIM:COUN?").strip()
        try:
            return int(response)
        except ValueError:
            raise ValueError(f"Unexpected response for system TIMer count (not integer): '{response}'")

    def set_system_timer_state(self, enable: bool):
        """
        Enables or disables the system timer.
        :param enable: True to enable, False to disable.
        """
        scpi_value = "1" if enable else "0"
        self.instrument.write(f":SYST:TIM:STATE {scpi_value}")

    def get_system_timer_state(self) -> bool:
        """
        Returns True if the system timer is enabled, False if disabled.
        """
        response = self.instrument.query(":SYST:TIM:STATE?").strip()
        if response == "1" or response.upper() == "ON":
            return True
        elif response == "0" or response.upper() == "OFF":
            return False
        else:
            raise ValueError(f"Unexpected response for system TIMer state: '{response}'")

    
    def set_system_tzone(self, hour_offset: int, minute_offset: int = None):
        """
        Sets the time zone offset from UTC.
        :param hour_offset: The hour offset (numeric value).
        :param minute_offset: Optional. The minute offset (numeric value).
        """
        if minute_offset is not None:
            self.instrument.write(f":SYST:TZON {hour_offset},{minute_offset}")
        else:
            self.instrument.write(f":SYST:TZON {hour_offset}")

    def get_system_tzone(self) -> tuple[int, int]:
        """
        Returns the time zone offset from UTC.
        :return: A tuple (hour_offset, minute_offset or None).
        """
        response = self.instrument.query(":SYST:TZON?").strip()
        try:
            parts = [int(p) for p in response.split(',')]
            if len(parts) == 1:
                return (parts[0], None)
            elif len(parts) == 2:
                return (parts[0], parts[1])
            else:
                raise ValueError("Unexpected time zone format.")
        except ValueError:
            raise ValueError(f"Unexpected response for system TZONE (not numeric or invalid format): '{response}'")

    
    def get_system_version(self) -> str:
        """
        Returns the SCPI version supported by the instrument.
        Notes: Query only.
        """
        response = self.instrument.query(":SYST:VERS?").strip()
        return response


    
    def get_system_error_next(self) -> tuple[int, str, str, str]:
        """
        Queries the next error from the error queue.
        Returns the full queue item consisting of an integer error number, a string
        error description, and optional device-dependent info and timestamp.
        Reading the error removes it from the queue.
        :return: A tuple (error_number, error_description, device_dependent_info, timestamp).
                 device_dependent_info and timestamp can be None if not present.
        """
        response = self.instrument.query(":SYST:ERR:NEXT?").strip()
        if response == '0,"No error"':
            return (0, "No error", None, None)

        try:
            # Split the response into number and quoted string
            # Example: -131, "Invalid suffix; FREQuency: CENT 2.0E+5 dBuV 1996/08/15 13:22:51.01"
            # Find the first comma to separate the number.
            first_comma_idx = response.find(',')
            if first_comma_idx == -1:
                raise ValueError("Invalid error response format: missing comma.")

            error_number_str = response[:first_comma_idx].strip()
            error_number = int(error_number_str)

            # The rest is the quoted string, remove surrounding quotes
            quoted_string = response[first_comma_idx + 1:].strip()
            if not (quoted_string.startswith('"') and quoted_string.endswith('"')):
                raise ValueError("Invalid error response format: string not quoted.")

            full_description = quoted_string[1:-1] # Remove leading/trailing quotes

            # Try to parse device-dependent info and timestamp
            description_parts = full_description.split(';', 1)
            error_description = description_parts[0].strip()
            device_dependent_info = None
            timestamp = None

            if len(description_parts) > 1:
                remaining_info = description_parts[1].strip()
                # Check for timestamp at the end: YYYY/MM/DD HH:MM:SS.sss
                timestamp_pattern = r'\d{4}/\d{2}/\d{2} \d{2}:\d{2}:\d{2}\.\d{2,3}$'
                match = re.search(timestamp_pattern, remaining_info)

                if match:
                    timestamp = match.group(0)
                    device_dependent_info = remaining_info[:match.start()].strip()
                    if not device_dependent_info: # If only timestamp was present after semicolon
                        device_dependent_info = None
                else:
                    device_dependent_info = remaining_info

            return (error_number, error_description, device_dependent_info, timestamp)

        except (ValueError, IndexError) as e:
            raise ValueError(f"Failed to parse error response '{response}': {e}")

    # Note: SYSTem:ERRor:ALL? and SYSTem:ERRor:CODE:ALL?
    # and SYSTem:ERRor:CODE[:NEXT]? and SYSTem:ERRor:COUNT?
    # are defined in system1.pdf, so they are already covered there.
    # The ADD/DEL/DEL:LIST for SYSTem:ERRor:ENABle are also in system1.pdf.

    
    def get_system_error_power_on(self) -> tuple[int, str]:
        """
        Queries the power on event.
        :return: A tuple (event_number, event_description).
        Notes: Event Number is -500.
        """
        # This is not a standard SCPI query that directly retrieves a single specific event
        # based on a subcommand like :POWERON?. Instead, events are read from the queue.
        # This function simulates retrieving the *latest* power-on event if it were in the queue.
        # In a real scenario, you'd read from the queue and filter.
        # As per the document, this event is reported to the queue.
        # This function provides the static information as if it were retrieved.
        # A direct query `:SYST:ERR:POWON?` is not defined in the provided document.
        # This function provides the *description* of the event.
        return (-500, "Power on")

    
    def get_system_error_user_request(self) -> tuple[int, str]:
        """
        Queries the user request event.
        :return: A tuple (event_number, event_description).
        Notes: Event Number is -600.
        """
        # Similar to power_on, this is not a direct query.
        # This function provides the static information as if it were retrieved.
        return (-600, "User request")

